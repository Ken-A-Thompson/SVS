# Paremeters for simulations run on 2018-01-03
# Ken A. Thompson
# exploring combinations for Fig. 2.


# general notes:

"Higher SGV means higher segregation variance (and hybrid load) at the outset. not surprising but I didn't anticipiate this.
Under parallel evolution, there's a pretty consistent pattern of lower hybrid load. code currently not working with no mutations. does the pattern go away at SGV = 0?"

########################
### FIXED PAREMETERS ###
########################

(strength of selection not really parametized)

n = 2 #phenotypic dimensions (positive integer)
K = 1000 #number of individuals (positive integer)
p_mut = 0.1 #probability of having mutation at any one locus (0<p<1) #set this to zero for de novo only
alpha = 0.1 #mutational sd (positive real number)
pop = np.random.binomial(1, p_mut, (K, n_muts)) #p_mut chance of having each of n_muts mutations, for all K individuals
mut = np.random.normal(0, alpha, (n_muts, n)) #create n_muts mutations, each with a random normal phenotypic effect in each n dimension with mean 0 and sd alpha
K_adapt = K #number of individuals (positive integer)
alpha_adapt = alpha #mutational sd (positive real number)
B = 2 #number of offspring per generation per parent (positive integer)
u = 0.001 #mutation probability per generation per genome (0<u<1)
remove_lost = True #If true, remove mutations that are lost (0 for all individuals)
remove = 'derived' #.. any derived (not from ancestor) mutation that is lost 
maxgen = 1000 #total number of generations populations adapt for
nHybrids = 50
outputFreq = 100 #generation interval between plotting

Ã¥##########################
### VARYING PAREMETERS ###
##########################

n_muts = 10 #number of mutations (positive integer)
theta1 = np.array([0.5] * n) #optimum phenotype for population 1
theta2 = np.array([0.5] * n) #optimum phenotype for population 2

# figure1
# Parallel adaptation to 0.5 with low SGV.

n_muts = 9 #number of mutations (positive integer)
theta1 = np.array([0.5] * n) #optimum phenotype for population 1
theta2 = np.array([0.5] * n) #optimum phenotype for population 2
alpha = 0.1 #mutational sd (positive real number)

# figure2
# divergent adaptation to 0.5 with low SGV.

n_muts = 9 #number of mutations (positive integer)
theta1 = np.array([0.5] * n) #optimum phenotype for population 1
theta2 = np.array([0.5] * n) #optimum phenotype for population 2
alpha = 0.1 #mutational sd (positive real number)

# figure3
# divergent adaptation to 0.5 with moderate SGV.

n_muts = 20 #number of mutations (positive integer)
theta1 = np.array([0.5] * n) #optimum phenotype for population 1
theta2 = np.array([-0.5] * n) #optimum phenotype for population 2
alpha = 0.1 #mutational sd (positive real number)

# figure4
# divergent adaptation to 0.5 with moderate SGV.

n_muts = 20 #number of mutations (positive integer)
theta1 = np.array([0.5] * n) #optimum phenotype for population 1
theta2 = np.array([0.5] * n) #optimum phenotype for population 2
alpha = 0.1 #mutational sd (positive real number)


# figure 5
# divergent adaptation to 0.5 with high SGV.

n_muts = 100 #number of mutations (positive integer)
theta1 = np.array([0.5] * n) #optimum phenotype for population 1
theta2 = np.array([0.5] * n) #optimum phenotype for population 2
alpha = 0.1 #mutational sd (positive real number)

# figure 6
# divergent adaptation to 0.5 with high SGV.

n_muts = 100 #number of mutations (positive integer)
theta1 = np.array([0.5] * n) #optimum phenotype for population 1
theta2 = np.array([-0.5] * n) #optimum phenotype for population 2
alpha = 0.1 #mutational sd (positive real number)