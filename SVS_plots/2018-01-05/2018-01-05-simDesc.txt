# Paremeters for simulations run on 2018-01-03
# Ken A. Thompson
# exploring combinations for Fig. 2.


# general notes:

"Higher SGV means higher segregation variance (and hybrid load) at the outset. not surprising but I didn't anticipiate this.
Under parallel evolution, there's a pretty consistent pattern of lower hybrid load. code currently not working with no mutations. does the pattern go away at SGV = 0?"

########################
### FIXED PAREMETERS ###
########################



nreps = 10 #number of replicates for each set of parameters
n = 2 #phenotypic dimensions (positive integer >=1)


K = 1000 #number of individuals (positive integer >=1)
n_mut_list = [0, 5, 10, 15, 20, 25] #number of mutations (positive integer >=1)
p_mut = 0.1 #probability of having mutation at any one locus (0<=p<=1) #set this to zero for de novo only
alpha = 0.1 #mutational sd (positive real number)


K_adapt = K #number of individuals (positive integer)
alpha_adapt = alpha #mutational sd (positive real number)
B = 2 #number of offspring per generation per parent (positive integer)
u = 0.001 #mutation probability per generation per genome (0<u<1)



maxgen = 1000 #total number of generations populations adapt for

remove_lost = True #If true, remove mutations that are lost (0 for all individuals)
remove = 'derived' #.. any derived (not from ancestor) mutation that is lost 

nHybrids = 100 #number of hybrids to make at end of each replicate


Ã¥##########################
### VARYING PAREMETERS ###
##########################

theta1 = np.array([n, n]) #optimum phenotype for population 1
theta2 = np.array([n, n]) #optimum phenotype for population 2
n_mut_list = [n,...] #number of mutations (positive integer >=1)

# figure1
# Parallel adaptation to 0.5

n_mut_list = [0, 5, 10, 15, 20, 25] #number of mutations (positive integer >=1)
theta1 = np.array([0.5,0.5]) #optimum phenotype for population 1
theta2 = np.array([0.5,0.5]) #optimum phenotype for population 2

# figure2
# Parallel adaptation to 0.5

n_mut_list = [0, 20, 40, 60, 80, 100] #number of mutations (positive integer >=1)
theta1 = np.array([0.5,0.5]) #optimum phenotype for population 1
theta2 = np.array([0.5,0.5]) #optimum phenotype for population 2

# figure3
# Divergent adaptation to 0.5 / -0.5

n_mut_list = [0, 20, 40, 60, 80, 100] #number of mutations (positive integer >=1)
theta1 = np.array([0.5,0.5]) #optimum phenotype for population 1
theta2 = np.array([-0.5,-0.5]) #optimum phenotype for population 2


